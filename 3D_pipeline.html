<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scrubber Pro 3D - V4.0 Connect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; touch-action: none; background-color: #f8fafc; }
        
        .grid-bg { 
            background-color: #f8fafc;
            background-image: linear-gradient(#cbd5e1 1px, transparent 1px), linear-gradient(90deg, #cbd5e1 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .panel-slide { transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); }
        .panel-hidden { transform: translateY(100%); }
        .btn-touch { transition: transform 0.1s; }
        .btn-touch:active { transform: scale(0.95); }

        /* V4.0 搖桿：樣式優化 */
        .joystick-base {
            position: absolute;
            bottom: 40px; left: 40px;
            width: 120px; height: 120px;
            background: rgba(0, 0, 0, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: auto; /* 讓它能接收點擊 */
            backdrop-filter: blur(4px);
            z-index: 60;
            touch-action: none;
            display: none; /* 預設隱藏，3D 模式顯示 */
        }
        
        .joystick-knob {
            position: absolute;
            left: 50%; top: 50%;
            margin-left: -25px; margin-top: -25px;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transform: translate(0px, 0px);
        }

        /* 3D 模式下的 UI 調整 */
        .mode-3d .joystick-base { display: block; }
        
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        .scrubber-marker {
            animation: pulse-ring 2s infinite;
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Top Bar -->
    <div class="fixed top-0 left-0 w-full h-14 bg-slate-900 text-white flex items-center justify-between px-4 z-50 shadow-md">
        <div class="flex items-center gap-2">
            <div class="p-1 bg-blue-500 rounded text-white"><i data-lucide="zap" class="w-5 h-5"></i></div>
            <div>
                <h1 class="font-bold text-lg leading-none">Scrubber 3D</h1>
                <span class="text-[10px] text-blue-300 font-mono">V4.0 AUTO-CONNECT</span>
            </div>
        </div>
        <div class="flex gap-3">
            <button onclick="toggle3D()" id="btn-3d" class="btn-touch px-3 py-1.5 bg-indigo-600 rounded-full font-bold text-xs flex items-center gap-1 shadow border border-indigo-400">
                <i data-lucide="box" class="w-4 h-4"></i> 3D 預覽
            </button>
            <button onclick="toggleSettings()" class="btn-touch p-2 bg-slate-700 rounded-full">
                <i data-lucide="menu" class="w-5 h-5"></i>
            </button>
        </div>
    </div>

    <!-- 2D Layer -->
    <div id="layer-2d" class="absolute inset-0 pt-14 z-0 overflow-hidden bg-slate-200">
        <div id="canvas-container" class="w-full h-full relative overflow-hidden grid-bg touch-none">
            <div id="canvas-content" class="absolute top-0 left-0 origin-top-left will-change-transform">
                <svg id="main-svg" width="3000" height="3000" class="block pointer-events-none">
                    <defs>
                        <pattern id="smallGrid" width="40" height="40" patternUnits="userSpaceOnUse">
                            <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#e2e8f0" stroke-width="1"/>
                        </pattern>
                    </defs>
                    <rect width="100%" height="100%" fill="url(#smallGrid)" />
                    
                    <g id="pipes-layer"></g>
                    <g id="scrubbers-layer"></g>
                    <line id="temp-line" x1="0" y1="0" x2="0" y2="0" stroke="#3b82f6" stroke-width="2" stroke-dasharray="5,5" class="hidden" />
                    
                    <g id="touch-cursor" class="hidden transition-transform duration-75">
                        <rect x="-20" y="-20" width="40" height="40" fill="rgba(59, 130, 246, 0.1)" stroke="#3b82f6" stroke-width="2" />
                        <circle r="4" fill="#3b82f6" />
                        <line x1="0" y1="-30" x2="0" y2="30" stroke="#3b82f6" stroke-width="1" stroke-dasharray="4 2"/>
                        <line x1="-30" y1="0" x2="30" y2="0" stroke="#3b82f6" stroke-width="1" stroke-dasharray="4 2"/>
                        <text id="cursor-label" x="10" y="-10" class="text-xs fill-blue-600 font-bold" style="font-size: 12px;">H:2.5</text>
                    </g>
                </svg>
            </div>
        </div>

        <!-- 2D Controls -->
        <div class="absolute right-4 top-20 flex flex-col gap-2 z-40">
            <button onclick="centerView()" class="btn-touch p-3 bg-white rounded-full shadow text-blue-600 border border-blue-100"><i data-lucide="crosshair" class="w-6 h-6"></i></button>
            <button onclick="zoom(0.1)" class="btn-touch p-3 bg-white rounded-full shadow text-slate-600 border border-slate-200"><i data-lucide="zoom-in" class="w-6 h-6"></i></button>
            <button onclick="zoom(-0.1)" class="btn-touch p-3 bg-white rounded-full shadow text-slate-600 border border-slate-200"><i data-lucide="zoom-out" class="w-6 h-6"></i></button>
        </div>

        <div class="absolute bottom-6 left-4 right-4 bg-white/95 backdrop-blur rounded-2xl shadow-xl p-2 flex justify-between items-center border border-slate-200 z-40 max-w-md mx-auto">
            <div class="flex bg-slate-100 p-1 rounded-xl gap-1 w-1/2">
                <button onclick="setTool('pan')" id="tool-pan" class="btn-touch flex-1 px-4 py-3 rounded-lg flex flex-col items-center justify-center gap-1 bg-white shadow text-blue-600 transition-colors">
                    <i data-lucide="move" class="w-5 h-5"></i>
                    <span class="text-[10px] font-bold">移動</span>
                </button>
                <button onclick="setTool('pipe')" id="tool-pipe" class="btn-touch flex-1 px-4 py-3 rounded-lg flex flex-col items-center justify-center gap-1 text-slate-400 transition-colors">
                    <i data-lucide="edit-3" class="w-5 h-5"></i>
                    <span class="text-[10px] font-bold">畫管</span>
                </button>
            </div>
            <div class="h-8 w-[1px] bg-slate-200 mx-2"></div>
            <button onclick="addScrubber()" class="btn-touch p-3 bg-slate-800 text-white rounded-xl shadow flex flex-col items-center"><i data-lucide="plus" class="w-6 h-6"></i></button>
            <button onclick="handleUndo()" class="btn-touch p-3 text-slate-600 hover:bg-slate-50 rounded-xl flex flex-col items-center"><i data-lucide="undo-2" class="w-6 h-6"></i></button>
            <button onclick="clearAll()" class="btn-touch p-3 text-red-500 hover:bg-red-50 rounded-xl flex flex-col items-center"><i data-lucide="trash-2" class="w-6 h-6"></i></button>
        </div>

        <div id="pipe-controls" class="absolute bottom-28 right-4 bg-white p-2 rounded-xl shadow-lg border border-slate-200 hidden flex-col items-center gap-2 animate-in fade-in slide-in-from-bottom-4 z-40">
            <span class="text-[10px] font-bold text-slate-400">高度 Z (m)</span>
            <button onclick="adjustZ(0.5)" class="p-2 bg-slate-100 rounded-lg active:bg-blue-100 hover:bg-blue-50"><i data-lucide="arrow-up" class="w-5 h-5 text-blue-600"></i></button>
            <span id="z-disp" class="font-mono font-bold text-blue-600 text-xl w-10 text-center border-y border-slate-100 py-1">2.5</span>
            <button onclick="adjustZ(-0.5)" class="p-2 bg-slate-100 rounded-lg active:bg-blue-100 hover:bg-blue-50"><i data-lucide="arrow-down" class="w-5 h-5 text-blue-600"></i></button>
        </div>
        
        <div id="toast" class="absolute top-20 left-1/2 -translate-x-1/2 bg-slate-800/90 text-white px-4 py-2 rounded-full text-sm font-bold shadow-lg opacity-0 pointer-events-none transition-opacity z-50 whitespace-nowrap">Msg</div>
    </div>

    <!-- 3D Layer -->
    <div id="layer-3d" class="fixed inset-0 bg-black z-50 hidden touch-none">
        <div id="container-3d" class="w-full h-full"></div>
        <button onclick="toggle3D()" class="absolute top-4 left-4 bg-white/20 backdrop-blur text-white px-4 py-2 rounded-full font-bold border border-white/30 z-50 flex items-center gap-2 active:bg-white/30">
            <i data-lucide="arrow-left" class="w-4 h-4"></i> 返回設計
        </button>
        <div class="absolute top-4 right-4 text-white/50 text-xs text-right pointer-events-none select-none z-50">
            <div>左手: 移動</div>
            <div>右手: 轉向</div>
            <div class="text-yellow-400">雙指: 縮放/升降</div>
        </div>

        <!-- 虛擬搖桿 (ID: joystick-zone) -->
        <div id="joystick-zone" class="joystick-base">
            <div id="stick-move" class="joystick-knob"></div>
        </div>
        
        <!-- 右側轉向區 -->
        <div id="touch-zone-look" class="absolute bottom-0 right-0 w-1/2 h-full z-40"></div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-panel" class="fixed inset-0 z-[60] bg-black/50 hidden opacity-0 transition-opacity duration-300">
        <div id="sheet-content" class="absolute bottom-0 left-0 w-full bg-white rounded-t-3xl shadow-2xl panel-hidden panel-slide h-[80vh] flex flex-col">
            <div class="w-full h-6 flex justify-center items-center cursor-pointer" onclick="toggleSettings()"><div class="w-12 h-1.5 bg-slate-300 rounded-full"></div></div>
            <div class="p-5 flex-1 overflow-y-auto">
                <h2 class="text-xl font-bold mb-6 flex items-center gap-2 text-slate-800"><i data-lucide="settings" class="w-6 h-6 text-blue-600"></i> 參數與報價</h2>
                <div class="space-y-6">
                    <div class="bg-slate-50 p-4 rounded-2xl border border-slate-100">
                        <label class="text-xs font-bold text-slate-400 uppercase mb-3 block">新增設備預設值</label>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <span class="text-sm font-bold text-slate-600 mb-1 block">CMM 風量</span>
                                <input type="number" id="param-cmm" value="150" class="w-full bg-white border border-slate-200 p-3 rounded-xl font-bold text-center text-lg">
                            </div>
                            <div>
                                <span class="text-sm font-bold text-slate-600 mb-1 block">設備形式</span>
                                <select id="param-type" class="w-full bg-white border border-slate-200 p-3 rounded-xl font-bold text-center appearance-none">
                                    <option value="vertical">立式 (圓)</option>
                                    <option value="horizontal">臥式 (方)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="bg-white border border-slate-200 rounded-2xl p-4 shadow-sm">
                        <div class="flex justify-between items-center mb-4 border-b pb-2"><h3 class="font-bold text-slate-700">專案估價單 (概算)</h3><span class="text-xs text-slate-400">含稅 5%</span></div>
                        <div id="bom-list" class="space-y-3 text-sm mb-4"><div class="text-center text-slate-400 py-2">無項目</div></div>
                        <div class="flex justify-between items-center pt-3 border-t-2 border-slate-100"><span class="font-bold text-slate-500">總計</span><span id="total-price" class="text-2xl font-black text-blue-600">$0</span></div>
                    </div>
                </div>
            </div>
            <div class="p-4 bg-white border-t border-slate-100 pb-8">
                <button onclick="toggleSettings()" class="w-full bg-slate-900 text-white py-4 rounded-xl font-bold active:scale-95 transition-transform">確認並關閉</button>
            </div>
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // CONFIG
        const GRID = 40;
        const GRID_METERS = 1; // 1 grid = 1 meter
        
        // STATE
        const state = {
            tool: 'pan', // pan, pipe
            pipes: [], // {x1, y1, z1, x2, y2, z2, type: 'horizontal'|'vertical', id}
            scrubbers: [], // {x, y, z, cmm, type}
            history: [], // For undo
            
            // View State
            viewX: 0, viewY: 0, scale: 1,
            z: 2.5, // Current drawing height
            
            // Interaction State
            isDrawing: false,
            lastPoint: null,
            lastPipeZ: 2.5,
            
            // 3D Player State
            playerPos: new THREE.Vector3(0, 20, 50),
            playerRot: new THREE.Euler(0, 0, 0),
            moveVector: { x: 0, z: 0 },
            is3D: false
        };

        // --- INIT ---
        window.onload = function() {
            lucide.createIcons();
            
            const container = document.getElementById('canvas-container');
            // Passive false for preventing scrolling
            ['touchstart','touchmove','touchend','mousedown','mousemove','mouseup','wheel'].forEach(e => 
                container.addEventListener(e, handle2DEvent, { passive: false })
            );

            // 3D Controls
            const joyZone = document.getElementById('joystick-zone');
            joyZone.addEventListener('touchstart', handleJoystick, { passive: false });
            joyZone.addEventListener('touchmove', handleJoystick, { passive: false });
            joyZone.addEventListener('touchend', handleJoystickEnd);
            
            const lookZone = document.getElementById('touch-zone-look');
            lookZone.addEventListener('touchstart', handleLook, { passive: false });
            lookZone.addEventListener('touchmove', handleLook, { passive: false });
            lookZone.addEventListener('touchend', () => lookPointer = null);

            // 3D Pinch (on the whole layer)
            const l3d = document.getElementById('layer-3d');
            l3d.addEventListener('touchstart', handle3DPinch, { passive: false });
            l3d.addEventListener('touchmove', handle3DPinch, { passive: false });
            l3d.addEventListener('touchend', () => pinchDistStart = 0);

            // Init 2D View Center
            state.viewX = - (3000 - window.innerWidth) / 2;
            state.viewY = - (3000 - window.innerHeight) / 2;
            updateTransform();

            // Setup Three.js scene once
            init3D();
        };

        // --- 2D LOGIC ---

        function setTool(t) {
            state.tool = t;
            state.isDrawing = false; // Reset drawing state
            state.lastPoint = null;
            document.getElementById('temp-line').classList.add('hidden');
            
            // UI Updates
            document.getElementById('tool-pan').className = `btn-touch flex-1 px-4 py-3 rounded-lg flex flex-col items-center justify-center gap-1 ${t==='pan' ? 'bg-white shadow text-blue-600' : 'text-slate-400'}`;
            document.getElementById('tool-pipe').className = `btn-touch flex-1 px-4 py-3 rounded-lg flex flex-col items-center justify-center gap-1 ${t==='pipe' ? 'bg-white shadow text-blue-600' : 'text-slate-400'}`;
            
            const pipeControls = document.getElementById('pipe-controls');
            if(t === 'pipe') {
                pipeControls.classList.remove('hidden');
                pipeControls.classList.add('flex');
            } else {
                pipeControls.classList.add('hidden');
                pipeControls.classList.remove('flex');
            }
            showToast(t === 'pan' ? "模式: 移動視圖" : "模式: 繪製管線");
        }

        function adjustZ(delta) {
            state.z = Math.max(0, Math.round((state.z + delta) * 10) / 10);
            document.getElementById('z-disp').innerText = state.z;
            document.getElementById('cursor-label').textContent = `H:${state.z}`;
            
            // If currently drawing, this triggers an auto-vertical pipe on next click
            if(state.isDrawing) {
                showToast(`高度變更: ${state.lastPipeZ}m -> ${state.z}m`);
            }
        }

        // 2D Interaction Vars
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };
        let pinchStartDist = 0;
        let scaleStart = 1;

        function handle2DEvent(e) {
            if(e.type === 'wheel') { handleWheel(e); return; }
            
            const isTouch = e.type.startsWith('touch');
            if(isTouch && e.touches.length > 1) {
                // Pinch logic
                if(e.type === 'touchstart') {
                    pinchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    scaleStart = state.scale;
                } else if (e.type === 'touchmove') {
                    e.preventDefault();
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    zoom((dist / pinchStartDist) * scaleStart - state.scale);
                }
                return;
            }

            const clientX = isTouch ? e.touches[0]?.clientX : e.clientX;
            const clientY = isTouch ? e.touches[0]?.clientY : e.clientY;

            if(e.type === 'touchstart' || e.type === 'mousedown') {
                isDragging = true;
                lastPos = { x: clientX, y: clientY };
                
                if(state.tool === 'pipe') {
                    handleTapGrid(clientX, clientY);
                }
            } else if (e.type === 'touchmove' || e.type === 'mousemove') {
                if(!isDragging) {
                     // Hover effect for mouse
                     if(!isTouch) updateCursor(getGridPoint(clientX, clientY));
                     return;
                }
                e.preventDefault(); // Prevent scroll
                
                const dx = clientX - lastPos.x;
                const dy = clientY - lastPos.y;

                if(state.tool === 'pan') {
                    state.viewX += dx;
                    state.viewY += dy;
                    updateTransform();
                } else if (state.tool === 'pipe' && state.isDrawing) {
                    const pt = getGridPoint(clientX, clientY);
                    updateCursor(pt);
                    // Update temp line
                    const temp = document.getElementById('temp-line');
                    temp.setAttribute('x1', state.lastPoint.x * GRID);
                    temp.setAttribute('y1', state.lastPoint.y * GRID);
                    temp.setAttribute('x2', pt.x * GRID);
                    temp.setAttribute('y2', pt.y * GRID);
                    temp.classList.remove('hidden');
                }
                lastPos = { x: clientX, y: clientY };
            } else if (e.type === 'touchend' || e.type === 'mouseup') {
                isDragging = false;
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            zoom(-e.deltaY * 0.001);
        }

        function zoom(delta) {
            const oldScale = state.scale;
            const newScale = Math.min(Math.max(0.2, state.scale + delta), 4); // Limit zoom
            if(newScale === oldScale) return;
            
            // Zoom towards center
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            state.viewX = cx - (cx - state.viewX) * (newScale / oldScale);
            state.viewY = cy - (cy - state.viewY) * (newScale / oldScale);
            state.scale = newScale;
            updateTransform();
            showToast(`縮放: ${Math.round(state.scale * 100)}%`);
        }

        function centerView() {
            if (state.pipes.length === 0 && state.scrubbers.length === 0) {
                // Reset to 0,0 if empty
                state.viewX = - (3000 - window.innerWidth) / 2;
                state.viewY = - (3000 - window.innerHeight) / 2;
                state.scale = 1;
                updateTransform();
                showToast("畫布已重置");
                return;
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            state.pipes.forEach(p => {
                minX = Math.min(minX, p.x1, p.x2);
                maxX = Math.max(maxX, p.x1, p.x2);
                minY = Math.min(minY, p.y1, p.y2);
                maxY = Math.max(maxY, p.y1, p.y2);
            });
            state.scrubbers.forEach(s => {
                minX = Math.min(minX, s.x);
                maxX = Math.max(maxX, s.x);
                minY = Math.min(minY, s.y);
                maxY = Math.max(maxY, s.y);
            });

            // Center in grid units
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            // Convert to pixels
            const px = cx * GRID;
            const py = cy * GRID;

            // Center on screen
            state.scale = 1;
            state.viewX = window.innerWidth / 2 - px;
            state.viewY = window.innerHeight / 2 - py;
            
            updateTransform();
            showToast("已定位至物件");
        }

        function updateTransform() {
            const content = document.getElementById('canvas-content');
            content.style.transform = `translate(${state.viewX}px, ${state.viewY}px) scale(${state.scale})`;
        }

        function getGridPoint(cx, cy) {
            const rect = document.getElementById('canvas-container').getBoundingClientRect();
            // Inverse transform
            const x = (cx - rect.left - state.viewX) / state.scale;
            const y = (cy - rect.top - state.viewY) / state.scale;
            return {
                x: Math.round(x / GRID),
                y: Math.round(y / GRID)
            };
        }

        function updateCursor(pt) {
            const cur = document.getElementById('touch-cursor');
            cur.setAttribute('transform', `translate(${pt.x * GRID}, ${pt.y * GRID})`);
            cur.classList.remove('hidden');
            document.getElementById('cursor-label').textContent = `H:${state.z}`;
        }

        function handleTapGrid(cx, cy) {
            const pt = getGridPoint(cx, cy);
            updateCursor(pt);
            
            if(state.tool === 'pipe') {
                saveHistory();
                if(!state.isDrawing) {
                    // Start Drawing
                    state.isDrawing = true;
                    state.lastPoint = pt;
                    state.lastPipeZ = state.z;
                    showToast(`起點設定 (H:${state.z}m)`);
                } else {
                    // Check if same point
                    if(pt.x === state.lastPoint.x && pt.y === state.lastPoint.y && state.z === state.lastPipeZ) return;

                    // Add Pipe logic
                    // 1. Check vertical connect
                    if(state.z !== state.lastPipeZ) {
                        state.pipes.push({
                            x1: state.lastPoint.x, y1: state.lastPoint.y, z1: state.lastPipeZ,
                            x2: state.lastPoint.x, y2: state.lastPoint.y, z2: state.z,
                            type: 'vertical',
                            id: Date.now() + 'v'
                        });
                        showToast("自動建立垂直管");
                    }
                    
                    // 2. Add horizontal segment (if points differ)
                    if(pt.x !== state.lastPoint.x || pt.y !== state.lastPoint.y) {
                         state.pipes.push({
                            x1: state.lastPoint.x, y1: state.lastPoint.y, z1: state.z,
                            x2: pt.x, y2: pt.y, z2: state.z,
                            type: 'horizontal',
                            id: Date.now() + 'h'
                        });
                    }

                    state.lastPoint = pt;
                    state.lastPipeZ = state.z;
                    render2D();
                    updateBOM();
                }
            }
        }

        function addScrubber() {
            saveHistory();
            // Place scrubber at center of screen approx
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            const pt = getGridPoint(cx, cy);
            
            state.scrubbers.push({
                x: pt.x, y: pt.y, z: 0,
                cmm: document.getElementById('param-cmm').value,
                type: document.getElementById('param-type').value,
                id: Date.now()
            });
            render2D();
            updateBOM();
            showToast("已新增洗滌塔");
        }

        function render2D() {
            const pipesLayer = document.getElementById('pipes-layer');
            const scrubbersLayer = document.getElementById('scrubbers-layer');
            
            pipesLayer.innerHTML = '';
            scrubbersLayer.innerHTML = '';

            // Render Pipes
            state.pipes.forEach(p => {
                if(p.type === 'horizontal') {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', p.x1 * GRID);
                    line.setAttribute('y1', p.y1 * GRID);
                    line.setAttribute('x2', p.x2 * GRID);
                    line.setAttribute('y2', p.y2 * GRID);
                    line.setAttribute('stroke', '#64748b');
                    line.setAttribute('stroke-width', 6);
                    line.setAttribute('stroke-linecap', 'round');
                    pipesLayer.appendChild(line);
                    
                    const inner = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    inner.setAttribute('x1', p.x1 * GRID);
                    inner.setAttribute('y1', p.y1 * GRID);
                    inner.setAttribute('x2', p.x2 * GRID);
                    inner.setAttribute('y2', p.y2 * GRID);
                    inner.setAttribute('stroke', '#94a3b8');
                    inner.setAttribute('stroke-width', 2);
                    pipesLayer.appendChild(inner);

                    // Height Label
                    const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    txt.setAttribute('x', (p.x1 + p.x2)/2 * GRID);
                    txt.setAttribute('y', (p.y1 + p.y2)/2 * GRID - 10);
                    txt.setAttribute('fill', '#64748b');
                    txt.setAttribute('text-anchor', 'middle');
                    txt.setAttribute('font-size', '10px');
                    txt.textContent = `H:${p.z1}`;
                    pipesLayer.appendChild(txt);
                } else {
                    // Vertical indicator (Circle)
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute('cx', p.x1 * GRID);
                    circle.setAttribute('cy', p.y1 * GRID);
                    circle.setAttribute('r', 8);
                    circle.setAttribute('fill', '#f59e0b');
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', 2);
                    pipesLayer.appendChild(circle);
                }
            });

            // Render Scrubbers
            state.scrubbers.forEach(s => {
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute('transform', `translate(${s.x * GRID}, ${s.y * GRID})`);
                
                if(s.type === 'vertical') {
                    const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    c.setAttribute('r', 25);
                    c.setAttribute('fill', '#3b82f6');
                    c.setAttribute('opacity', '0.8');
                    c.setAttribute('stroke', '#1d4ed8');
                    c.setAttribute('stroke-width', 2);
                    g.appendChild(c);
                } else {
                    const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    r.setAttribute('x', -25);
                    r.setAttribute('y', -25);
                    r.setAttribute('width', 50);
                    r.setAttribute('height', 50);
                    r.setAttribute('rx', 5);
                    r.setAttribute('fill', '#3b82f6');
                    r.setAttribute('opacity', '0.8');
                    r.setAttribute('stroke', '#1d4ed8');
                    r.setAttribute('stroke-width', 2);
                    g.appendChild(r);
                }
                
                const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                label.setAttribute('y', 40);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'text-xs font-bold fill-slate-700');
                label.textContent = `SCR-${s.cmm}`;
                g.appendChild(label);
                
                scrubbersLayer.appendChild(g);
            });
        }

        // --- 3D LOGIC (Three.js) ---
        let scene, camera, renderer;
        let playerVelocity = new THREE.Vector3();
        let joyVector = { x: 0, y: 0 };
        let lookPointer = null;
        let lookEuler = { yaw: 0, pitch: 0 };
        let pinchDistStart = 0;

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a); // Slate 900
            scene.fog = new THREE.Fog(0x0f172a, 20, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container-3d').appendChild(renderer.domElement);

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Floor
            const gridHelper = new THREE.GridHelper(200, 200, 0x1e293b, 0x1e293b);
            scene.add(gridHelper);
            const planeGeo = new THREE.PlaneGeometry(200, 200);
            const planeMat = new THREE.MeshLambertMaterial({ color: 0x0f172a });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            animate3D();
        }

        function buildScene() {
            // Remove old meshes (keep lights and grid)
            for(let i = scene.children.length - 1; i >= 0; i--) {
                const obj = scene.children[i];
                if(obj.userData.isGameObj) scene.remove(obj);
            }

            // Build Pipes
            const pipeMat = new THREE.MeshStandardMaterial({ color: 0xcbd5e1, roughness: 0.3, metalness: 0.1 }); // Slate 300
            
            state.pipes.forEach(p => {
                // Convert grid units to meters (1 grid = 1 meter approx)
                // In Three.js: X is X, Y is UP (Z in 2D), Z is Z (Y in 2D)
                // 2D: (x, y) -> 3D: (x, -y) or (x, z)
                // Let's map 2D(x,y) to 3D(x, z). 2D(z) to 3D(y)
                
                const u = 2; // Unit scale multiplier for visualization size
                const x1 = p.x1 * u;
                const z1 = p.y1 * u;
                const y1 = p.z1 * u;
                const x2 = p.x2 * u;
                const z2 = p.y2 * u;
                const y2 = p.z2 * u;

                const dx = x2 - x1;
                const dy = y2 - y1;
                const dz = z2 - z1;
                const len = Math.sqrt(dx*dx + dy*dy + dz*dz);

                const geometry = new THREE.CylinderGeometry(0.3, 0.3, len, 16);
                const mesh = new THREE.Mesh(geometry, pipeMat);
                
                // Position at midpoint
                mesh.position.set(x1 + dx/2, y1 + dy/2, z1 + dz/2);
                
                // Rotation
                // Default cylinder is vertical (along Y).
                // We need to rotate it to match vector (dx, dy, dz)
                if (len > 0.001) {
                    const axis = new THREE.Vector3(0, 1, 0);
                    const target = new THREE.Vector3(dx, dy, dz).normalize();
                    mesh.quaternion.setFromUnitVectors(axis, target);
                }
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.isGameObj = true;
                scene.add(mesh);
                
                // Add joints (Spheres)
                const jointGeo = new THREE.SphereGeometry(0.35, 16, 16);
                const joint1 = new THREE.Mesh(jointGeo, pipeMat);
                joint1.position.set(x1, y1, z1);
                joint1.userData.isGameObj = true;
                scene.add(joint1);
                
                const joint2 = new THREE.Mesh(jointGeo, pipeMat);
                joint2.position.set(x2, y2, z2);
                joint2.userData.isGameObj = true;
                scene.add(joint2);
            });

            // Build Scrubbers
            state.scrubbers.forEach(s => {
                const u = 2;
                const x = s.x * u;
                const z = s.y * u;
                const y = 0; // On ground
                
                let geo;
                if(s.type === 'vertical') {
                    geo = new THREE.CylinderGeometry(1.5, 1.5, 6, 32);
                } else {
                    geo = new THREE.BoxGeometry(3, 4, 3);
                }
                const mat = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, 3, z); // Center y at 3 (height 6)
                mesh.castShadow = true;
                mesh.userData.isGameObj = true;
                scene.add(mesh);
            });
            
            // Auto-Focus Player Position logic
            if(state.pipes.length > 0 || state.scrubbers.length > 0) {
                let sumX = 0, sumZ = 0, count = 0;
                
                state.pipes.forEach(p => {
                    sumX += (p.x1 + p.x2) * 2 / 2; // Average x * unit scale
                    sumZ += (p.y1 + p.y2) * 2 / 2;
                    count++;
                });
                state.scrubbers.forEach(s => {
                    sumX += s.x * 2;
                    sumZ += s.y * 2;
                    count++;
                });
                
                if(count > 0) {
                    const centerX = sumX / count;
                    const centerZ = sumZ / count;
                    // Position player slightly back and up
                    state.playerPos.set(centerX, 20, centerZ + 40);
                    // Reset look to face 0,0 roughly (or just straight ahead)
                    lookEuler.yaw = 0; 
                    lookEuler.pitch = -0.3;
                }
            } else {
                // Default if empty
                state.playerPos.set(0, 10, 20);
                lookEuler.yaw = 0;
                lookEuler.pitch = 0;
            }
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if(!state.is3D) return;

            // Movement Logic
            const speed = 0.3;
            // JoyVector.y is negative when dragging up (screen coords), but we want forward (-z)
            // Forward/Back based on Look Yaw
            
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), lookEuler.yaw);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), lookEuler.yaw);
            
            // joyVector y < 0 is UP on screen -> move Forward
            // joyVector x > 0 is RIGHT on screen -> move Right
            
            state.playerPos.addScaledVector(forward, -joyVector.y * speed * 0.05); // -y is forward
            state.playerPos.addScaledVector(right, joyVector.x * speed * 0.05);

            camera.position.copy(state.playerPos);
            camera.rotation.set(lookEuler.pitch, lookEuler.yaw, 0, 'YXZ');
            
            renderer.render(scene, camera);
        }

        // --- 3D CONTROLS ---

        function toggle3D() {
            state.is3D = !state.is3D;
            const l3d = document.getElementById('layer-3d');
            const body = document.body;
            
            if(state.is3D) {
                l3d.classList.remove('hidden');
                body.classList.add('mode-3d');
                buildScene();
            } else {
                l3d.classList.add('hidden');
                body.classList.remove('mode-3d');
            }
        }

        function handleJoystick(e) {
            e.preventDefault();
            const t = e.touches[0];
            const zone = document.getElementById('joystick-zone');
            const rect = zone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let dx = t.clientX - centerX;
            let dy = t.clientY - centerY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = 40;
            
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            
            const knob = document.getElementById('stick-move');
            knob.style.transform = `translate(${dx}px, ${dy}px)`;
            
            joyVector = { x: dx, y: dy };
        }

        function handleJoystickEnd(e) {
            document.getElementById('stick-move').style.transform = `translate(0px, 0px)`;
            joyVector = { x: 0, y: 0 };
        }

        function handleLook(e) {
            e.preventDefault();
            const t = e.touches[0];
            if(!lookPointer) {
                lookPointer = { x: t.clientX, y: t.clientY };
                return;
            }
            
            const dx = t.clientX - lookPointer.x;
            const dy = t.clientY - lookPointer.y;
            
            const sensitivity = 0.005;
            lookEuler.yaw -= dx * sensitivity;
            lookEuler.pitch -= dy * sensitivity;
            
            // Clamp pitch
            lookEuler.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, lookEuler.pitch));
            
            lookPointer = { x: t.clientX, y: t.clientY };
        }

        function handle3DPinch(e) {
            if(e.touches.length < 2) return;
            e.preventDefault();
            
            // Height control with two fingers vertical movement roughly
            const y1 = e.touches[0].clientY;
            const y2 = e.touches[1].clientY;
            const avgY = (y1 + y2) / 2;
            
            if(!pinchDistStart) {
                pinchDistStart = avgY; // use Y pos to detect slide up/down
                return;
            }
            
            const dy = pinchDistStart - avgY; // Moving up is positive
            state.playerPos.y += dy * 0.05;
            state.playerPos.y = Math.max(1, state.playerPos.y); // Floor clamp
            
            pinchDistStart = avgY;
        }

        // --- UTILS & UI ---
        
        function saveHistory() {
            if(state.history.length > 10) state.history.shift();
            state.history.push({
                pipes: JSON.parse(JSON.stringify(state.pipes)),
                scrubbers: JSON.parse(JSON.stringify(state.scrubbers))
            });
        }

        function handleUndo() {
            if(state.history.length === 0) {
                showToast("無動作可復原");
                return;
            }
            const prev = state.history.pop();
            state.pipes = prev.pipes;
            state.scrubbers = prev.scrubbers;
            state.isDrawing = false;
            document.getElementById('temp-line').classList.add('hidden');
            render2D();
            updateBOM();
            showToast("已復原");
        }

        function clearAll() {
            if(!confirm("確定要清空畫布嗎？")) return;
            saveHistory();
            state.pipes = [];
            state.scrubbers = [];
            state.isDrawing = false;
            render2D();
            updateBOM();
            setTool('pan');
        }

        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            const sheet = document.getElementById('sheet-content');
            
            if(panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                // Allow reflow
                setTimeout(() => {
                    panel.classList.remove('opacity-0');
                    sheet.classList.remove('panel-hidden');
                }, 10);
                updateBOM(); // Refresh calculation
            } else {
                sheet.classList.add('panel-hidden');
                panel.classList.add('opacity-0');
                setTimeout(() => {
                    panel.classList.add('hidden');
                }, 300);
            }
        }

        function updateBOM() {
            let totalPipeLen = 0;
            state.pipes.forEach(p => {
                const dx = p.x2 - p.x1;
                const dy = p.y2 - p.y1;
                const dz = p.z2 - p.z1;
                totalPipeLen += Math.sqrt(dx*dx + dy*dy + dz*dz);
            });
            
            const scrubCount = state.scrubbers.length;
            const pipePrice = Math.round(totalPipeLen * 1500); // 1500 per meter
            const scrubPrice = scrubCount * 250000;
            const total = pipePrice + scrubPrice;
            
            const list = document.getElementById('bom-list');
            list.innerHTML = `
                <div class="flex justify-between py-1 border-b border-slate-50">
                    <span>PP管線工程 (${Math.round(totalPipeLen)}m)</span>
                    <span class="font-mono">$${pipePrice.toLocaleString()}</span>
                </div>
                <div class="flex justify-between py-1 border-b border-slate-50">
                    <span>洗滌塔設備 (${scrubCount}座)</span>
                    <span class="font-mono">$${scrubPrice.toLocaleString()}</span>
                </div>
            `;
            document.getElementById('total-price').textContent = '$' + total.toLocaleString();
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.style.opacity = '1';
            clearTimeout(window.toastTimer);
            window.toastTimer = setTimeout(() => t.style.opacity = '0', 2000);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

    </script>
</body>
</html>
